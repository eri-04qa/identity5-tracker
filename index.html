<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>第五人格トラッカー</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      min-height: 100vh;
      padding: 20px;
    }
    
    .container {
      max-width: 1200px;
      margin: 0 auto;
      background: white;
      border-radius: 12px;
      box-shadow: 0 10px 40px rgba(0,0,0,0.2);
      overflow: hidden;
    }
    
    .header {
      background: linear-gradient(135deg, #0f3460 0%, #16213e 100%);
      color: white;
      padding: 25px;
      text-align: center;
    }
    
    .header h1 {
      font-size: 32px;
      margin-bottom: 5px;
      font-weight: 700;
    }
    
    .header .subtitle {
      font-size: 14px;
      opacity: 0.9;
      font-weight: 400;
    }
    
    .perspective-tabs {
      display: flex;
      background: #f8f9fa;
      border-bottom: 2px solid #e0e0e0;
    }
    
    .perspective-tab {
      flex: 1;
      padding: 15px;
      text-align: center;
      cursor: pointer;
      background: #f8f9fa;
      border: none;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .perspective-tab.active {
      background: white;
      color: #0f3460;
      border-bottom: 3px solid #0f3460;
    }
    
    .perspective-tab:hover {
      background: #e9ecef;
    }
    
    .main-tabs {
      display: flex;
      background: #f8f9fa;
      border-bottom: 1px solid #dee2e6;
      overflow-x: auto;
    }
    
    .main-tab {
      padding: 12px 20px;
      cursor: pointer;
      background: #f8f9fa;
      border: none;
      font-size: 14px;
      white-space: nowrap;
      transition: all 0.3s;
    }
    
    .main-tab.active {
      background: white;
      color: #0f3460;
      border-bottom: 2px solid #0f3460;
    }
    
    .main-tab:hover {
      background: #e9ecef;
    }
    
    .content {
      padding: 25px;
    }
    
    .tab-content {
      display: none;
    }
    
    .tab-content.active {
      display: block;
    }
    
    .form-group {
      margin-bottom: 20px;
    }
    
    .form-label {
      display: block;
      margin-bottom: 8px;
      font-weight: 600;
      color: #333;
    }
    
    select {
      width: 100%;
      padding: 10px;
      border: 2px solid #ddd;
      border-radius: 6px;
      font-size: 14px;
      background: white;
    }
    
    select:focus {
      outline: none;
      border-color: #0f3460;
    }
    
    .result-buttons {
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
      margin-top: 10px;
    }
    
    .result-button {
      padding: 15px;
      border: 2px solid #ddd;
      border-radius: 6px;
      background: white;
      cursor: pointer;
      font-size: 16px;
      font-weight: 600;
      transition: all 0.3s;
    }
    
    .result-button:hover {
      border-color: #0f3460;
      background: #e6f0ff;
    }
    
    .result-button.selected {
      background: #0f3460;
      color: white;
      border-color: #0f3460;
    }
    
    .submit-button {
      width: 100%;
      padding: 15px;
      background: linear-gradient(135deg, #0f3460 0%, #533483 100%);
      color: white;
      border: none;
      border-radius: 6px;
      font-size: 16px;
      font-weight: 600;
      cursor: pointer;
      margin-top: 20px;
      transition: transform 0.2s;
    }
    
    .submit-button:hover {
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(15, 52, 96, 0.4);
    }
    
    .submit-button:active {
      transform: translateY(0);
    }
    
    .filter-section {
      background: #f8f9fa;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      align-items: center;
    }
    
    .filter-group {
      flex: 1;
      min-width: 200px;
    }
    
    .filter-label {
      display: block;
      margin-bottom: 5px;
      font-size: 14px;
      font-weight: 600;
      color: #333;
    }
    
    .stats-card {
      background: #f8f9fa;
      padding: 20px;
      border-radius: 8px;
      margin-bottom: 20px;
    }
    
    .stats-title {
      font-size: 18px;
      font-weight: 600;
      margin-bottom: 15px;
      color: #333;
    }
    
    .overall-stats-display {
      background: white;
      padding: 30px;
      border-radius: 8px;
      text-align: center;
    }
    
    .winrate-big {
      font-size: 48px;
      font-weight: 700;
      color: #0f3460;
      margin-bottom: 10px;
    }
    
    .record-text {
      font-size: 18px;
      color: #666;
      margin-bottom: 10px;
    }
    
    .streak-badge {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      background: linear-gradient(135deg, #ff6b6b, #ee5a6f);
      color: white;
      padding: 8px 16px;
      border-radius: 20px;
      font-size: 16px;
      font-weight: 600;
      margin-top: 10px;
    }
    
    .streak-icon {
      font-size: 20px;
    }
    
    /* 横棒グラフスタイル */
    .bar-chart-horizontal {
      display: flex;
      flex-direction: column;
      gap: 12px;
      padding: 20px;
      background: white;
      border-radius: 8px;
    }
    
    .bar-row {
      display: flex;
      align-items: center;
      gap: 12px;
      width: 100%;
      min-height: 45px;
    }
    
    .bar-label-wrapper {
      min-width: 110px;
      max-width: 110px;
      flex-shrink: 0;
    }
    
    .bar-label {
      font-size: 13px;
      font-weight: 600;
      color: #333;
      word-wrap: break-word;
      margin-bottom: 3px;
    }
    
    .bar-sublabel {
      font-size: 10px;
      color: #999;
      line-height: 1.3;
    }
    
    .bar-wrapper {
      flex: 1;
      min-width: 0;
      height: 28px;
      background: #f0f0f0;
      border-radius: 4px;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
    }
    
    .bar-visual {
      height: 100%;
      background: linear-gradient(90deg, #60a5fa, #3b82f6);
      border-radius: 4px;
      transition: width 0.3s ease;
      position: relative;
      display: flex;
      align-items: center;
      justify-content: flex-end;
      padding-right: 10px;
    }
    
    .bar-value {
      color: white;
      font-size: 11px;
      font-weight: 700;
      white-space: nowrap;
    }
    
    .bar-value-zero {
      position: static;
      transform: none;
      color: #999;
      background: transparent;
      font-size: 11px;
      font-weight: 600;
      padding-left: 10px;
    }
    
    .match-history {
      background: white;
      border: 1px solid #dee2e6;
      border-radius: 6px;
      overflow: hidden;
    }
    
    .match-item {
      padding: 15px;
      border-bottom: 1px solid #dee2e6;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .match-item:last-child {
      border-bottom: none;
    }
    
    .match-info {
      flex: 1;
    }
    
    .match-result {
      padding: 5px 12px;
      border-radius: 4px;
      font-size: 12px;
      font-weight: 600;
      margin-right: 10px;
    }
    
    .match-result.win {
      background: #d4edda;
      color: #155724;
    }
    
    .match-result.lose {
      background: #f8d7da;
      color: #721c24;
    }
    
    .match-result.draw {
      background: #fff3cd;
      color: #856404;
    }
    
    .match-actions button {
      margin-left: 5px;
      padding: 6px 12px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 12px;
    }
    
    .edit-button {
      background: #ffc107;
      color: #000;
    }
    
    .delete-button {
      background: #dc3545;
      color: white;
    }
    
    .reset-button {
      background: #dc3545;
      color: white;
      padding: 10px 20px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      font-size: 14px;
      margin-top: 20px;
    }
    
    .reset-button:hover {
      background: #c82333;
    }
    
    .empty-state {
      text-align: center;
      padding: 40px;
      color: #999;
    }
    
    .empty-state-icon {
      font-size: 48px;
      margin-bottom: 10px;
    }
  </style>
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>第五人格トラッカー</h1>
      <div class="subtitle">戦績管理・勝率計算</div>
    </div>
    
    <div class="perspective-tabs">
      <button class="perspective-tab active" onclick="switchPerspective('survivor')">サバイバー</button>
      <button class="perspective-tab" onclick="switchPerspective('hunter')">ハンター</button>
    </div>
    
    <div class="main-tabs">
      <button class="main-tab active" onclick="switchTab('input')">試合入力</button>
      <button class="main-tab" onclick="switchTab('character')">自キャラ別勝率</button>
      <button class="main-tab" onclick="switchTab('map')">マップ別勝率</button>
      <button class="main-tab" onclick="switchTab('opponent')">対戦相手別勝率</button>
      <button class="main-tab" onclick="switchTab('history')">試合履歴</button>
    </div>
    
    <div class="content">
      <!-- 試合入力タブ -->
      <div id="input-tab" class="tab-content active">
        <div id="overall-stats-inline"></div>
        
        <div id="survivor-input">
          <!-- スクショアップロード -->
          <div class="screenshot-upload-section" style="margin-bottom: 20px; text-align: center;">
            <button type="button" class="screenshot-upload-btn" onclick="document.getElementById('survivor-screenshot').click()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
              スクショから自動入力
            </button>
            <input type="file" id="survivor-screenshot" accept="image/*" style="display: none;" onchange="analyzeScreenshot('survivor', this)">
            <div id="survivor-analysis-status" style="margin-top: 10px; font-size: 13px; color: #666;"></div>
          </div>
          
          <div class="form-group">
            <label class="form-label">段位</label>
            <select id="survivor-rank">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">自分のサバイバー</label>
            <select id="my-survivor" onchange="updateSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">味方サバイバー1</label>
            <select id="teammate-1" onchange="updateSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">味方サバイバー2</label>
            <select id="teammate-2" onchange="updateSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">味方サバイバー3</label>
            <select id="teammate-3" onchange="updateSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手ハンター</label>
            <select id="opponent-hunter">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">マップ</label>
            <select id="survivor-map">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">脱出人数</label>
            <div class="result-buttons">
              <button class="result-button" onclick="selectEscapeCount('survivor', 0)">0人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 1)">1人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 2)">2人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 3)">3人</button>
              <button class="result-button" onclick="selectEscapeCount('survivor', 4)">4人</button>
            </div>
          </div>
          
          <button class="submit-button" onclick="submitMatch('survivor')">試合を記録</button>
        </div>
        
        <div id="hunter-input" style="display: none;">
          <!-- スクショアップロード -->
          <div class="screenshot-upload-section" style="margin-bottom: 20px; text-align: center;">
            <button type="button" class="screenshot-upload-btn" onclick="document.getElementById('hunter-screenshot').click()" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 12px 24px; border: none; border-radius: 8px; cursor: pointer; font-size: 14px; font-weight: 600; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">
              スクショから自動入力
            </button>
            <input type="file" id="hunter-screenshot" accept="image/*" style="display: none;" onchange="analyzeScreenshot('hunter', this)">
            <div id="hunter-analysis-status" style="margin-top: 10px; font-size: 13px; color: #666;"></div>
          </div>
          
          <div class="form-group">
            <label class="form-label">段位</label>
            <select id="hunter-rank">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">自分のハンター</label>
            <select id="my-hunter">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手サバイバー1</label>
            <select id="opponent-survivor-1" onchange="updateOpponentSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手サバイバー2</label>
            <select id="opponent-survivor-2" onchange="updateOpponentSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手サバイバー3</label>
            <select id="opponent-survivor-3" onchange="updateOpponentSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">相手サバイバー4</label>
            <select id="opponent-survivor-4" onchange="updateOpponentSurvivorSelects()">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">マップ</label>
            <select id="hunter-map">
              <option value="">選択してください</option>
            </select>
          </div>
          
          <div class="form-group">
            <label class="form-label">脱出人数</label>
            <div class="result-buttons">
              <button class="result-button" onclick="selectEscapeCount('hunter', 0)">0人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 1)">1人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 2)">2人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 3)">3人</button>
              <button class="result-button" onclick="selectEscapeCount('hunter', 4)">4人</button>
            </div>
          </div>
          
          <button class="submit-button" onclick="submitMatch('hunter')">試合を記録</button>
        </div>
      </div>
      
      <!-- 自キャラ別勝率タブ -->
      <div id="character-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="character-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
        </div>
        <div id="character-stats"></div>
      </div>
      
      <!-- マップ別勝率タブ -->
      <div id="map-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="map-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">自キャラフィルター</label>
            <select id="map-char-filter" onchange="updateAllStats()">
              <option value="all">全キャラ</option>
            </select>
          </div>
        </div>
        <div id="map-stats"></div>
      </div>
      
      <!-- 対戦相手別勝率タブ -->
      <div id="opponent-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="opponent-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">自キャラフィルター</label>
            <select id="my-char-filter" onchange="onMyCharFilterChange()">
              <option value="all">全キャラ</option>
            </select>
          </div>
          <div class="filter-group">
            <label class="filter-label">マップフィルター</label>
            <select id="opponent-map-filter" onchange="updateAllStats()">
              <option value="all">全マップ</option>
            </select>
          </div>
        </div>
        <div id="opponent-stats"></div>
      </div>
      
      <!-- 試合履歴タブ -->
      <div id="history-tab" class="tab-content">
        <div class="filter-section">
          <div class="filter-group">
            <label class="filter-label">段位フィルター</label>
            <select id="history-rank-filter" onchange="updateAllStats()">
              <option value="all">全段位</option>
            </select>
          </div>
        </div>
        <div id="match-history"></div>
        <button class="reset-button" onclick="resetAllData()">全データをリセット</button>
      </div>
    </div>
  </div>

  <script>
    const SURVIVORS = ['幸運児', '医師', '弁護士', '泥棒', '庭師', 'マジシャン', '冒険家', '傭兵', '祭司', '空軍', '機械技師', 'オフェンス', '心眼', '調香師', 'カウボーイ', '踊り子', '占い師', '納棺師', '探鉱者', '呪術師', '野人', '曲芸師', '一等航海士', 'バーメイド', 'ポストマン', '墓守', '「囚人」', '昆虫学者', '画家', 'バッツマン', '玩具職人', '患者', '「心理学者」', '小説家', '「少女」', '泣きピエロ', '教授', '骨董商', '作曲家', '記者', '航空エンジニア', '応援団', '人形師', '火災調査員', '「レディ・ファウロ」', '「騎士」', '気象学者', '弓使い', '「脱出マスター」', '幻灯師', '闘牛士'];
    
    const HUNTERS = ['復讐者', '道化師', '断罪狩人', 'リッパー', '結魂者', '芸者', '白黒無常', '写真家', '狂眼', '黄衣の王', '夢の魔女', '泣き虫', '魔トカゲ', '血の女王', 'ガードNo.26', '「使徒」', 'ヴァイオリニスト', '彫刻師', 'アンデッド', '破輪', '漁師', '蝋人形師', '「悪夢」', '書記官', '隠者', '夜の番人', 'オペラ歌手', '「フールズ・ゴールド」', '時空の影', '「足萎えの羊」', '「フラバルー」', '雑貨商', '「ビリヤードプレイヤー」', '「女王蜂」'];
    
    const MAPS = ['軍需工場', '赤の教会', '聖心病院', '湖景村', '月の河公園', 'レオの思い出', '永眠町', '中華街', '罪の森'];
    
    const RANKS = ['1段', '2段', '3段', '4段', '5段', '6段', '7段', '最高峰'];
    
    let currentPerspective = 'survivor';
    let selectedEscapeCount = { survivor: null, hunter: null };
    let matches = [];
    let editingMatchId = null;
    
    // 初期化
    function init() {
      populateSelects();
      updateSurvivorSelects(); // サバイバー選択肢の初期化
      updateOpponentSurvivorSelects(); // 相手サバイバー選択肢の初期化
      loadData(); // データを読み込む
      updateAllWithFilters(); // フィルターと統計を更新
    }
    
    // 画像解析関数
    async function analyzeScreenshot(perspective, input) {
      const file = input.files[0];
      if (!file) return;
      
      const statusElement = document.getElementById(`${perspective}-analysis-status`);
      statusElement.textContent = '解析中... (10-20秒程度かかります)';
      statusElement.style.color = '#3b82f6';
      
      try {
        // 画像をBase64に変換
        const base64 = await new Promise((resolve, reject) => {
          const reader = new FileReader();
          reader.onload = () => resolve(reader.result.split(',')[1]);
          reader.onerror = reject;
          reader.readAsDataURL(file);
        });
        
        // Claude APIで解析
        const response = await fetch('https://api.anthropic.com/v1/messages', {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
          },
          body: JSON.stringify({
            model: 'claude-sonnet-4-20250514',
            max_tokens: 2000,
            messages: [{
              role: 'user',
              content: [
                {
                  type: 'image',
                  source: {
                    type: 'base64',
                    media_type: file.type,
                    data: base64
                  }
                },
                {
                  type: 'text',
                  text: generateAnalysisPrompt(perspective)
                }
              ]
            }]
          })
        });
        
        // レスポンスのステータスを確認
        if (!response.ok) {
          const errorText = await response.text();
          console.error('API Error:', response.status, errorText);
          throw new Error(`API Error: ${response.status} - ${errorText}`);
        }
        
        const data = await response.json();
        console.log('API Response:', data); // デバッグ用
        
        if (data.content && data.content[0] && data.content[0].text) {
          const result = parseAnalysisResult(data.content[0].text);
          console.log('Parsed Result:', result); // デバッグ用
          
          if (result) {
            applyAnalysisResult(perspective, result);
            statusElement.textContent = '✅ 解析完了！内容を確認して登録してください';
            statusElement.style.color = '#10b981';
          } else {
            throw new Error('JSON解析に失敗しました');
          }
        } else {
          console.error('Unexpected response format:', data);
          throw new Error('解析結果の取得に失敗しました');
        }
        
      } catch (error) {
        console.error('解析エラー:', error);
        
        // エラーメッセージをより詳細に表示
        let errorMessage = '❌ 解析に失敗しました。';
        if (error.message.includes('API Error')) {
          errorMessage += ' APIエラーが発生しました。';
        } else if (error.message.includes('JSON')) {
          errorMessage += ' データの解析に失敗しました。';
        } else if (error.message.includes('Failed to fetch')) {
          errorMessage += ' ネットワークエラーです。インターネット接続を確認してください。';
        }
        
        statusElement.textContent = errorMessage;
        statusElement.style.color = '#dc3545';
      }
      
      // ファイル入力をリセット
      input.value = '';
    }
    
    // 解析プロンプトを生成
    function generateAnalysisPrompt(perspective) {
      return `この画像は第五人格（Identity V）のランク戦の試合結果画面です。
以下の情報を抽出してJSON形式で返してください。

【画面の構成】
- 1行目：ハンター
- 2-5行目：サバイバー4人
- 右側に「自分」と書かれている行が自キャラ

【勝敗の表記】
- 完全勝利 → 勝利
- 辛勝 → 引き分け
- 完全敗北 → 敗北

【脱出人数】
「脱出」と表示されている人数をカウント

【段位アイコン】
名前の横の小さなアイコンから段位を判別：
1段、2段、3段、4段、5段、6段、7段、最高峰

【必ず返すJSON形式】
{
  "map": "マップ名",
  "rank": "段位",
  "result": "勝利 or 引き分け or 敗北",
  "escapeCount": 数値,
  "myCharacter": "自キャラ名",
  ${perspective === 'survivor' ? 
    '"teammates": ["味方1", "味方2", "味方3"], "opponentHunter": "ハンター名"' :
    '"opponentSurvivors": ["サバイバー1", "サバイバー2", "サバイバー3", "サバイバー4"]'
  }
}

JSONのみを返してください。説明文は不要です。`;
    }
    
    // 解析結果をパース
    function parseAnalysisResult(text) {
      try {
        // JSONを抽出（```json ``` で囲まれている場合に対応）
        const jsonMatch = text.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          return JSON.parse(jsonMatch[0]);
        }
        return JSON.parse(text);
      } catch (error) {
        console.error('JSON解析エラー:', error);
        return null;
      }
    }
    
    // 解析結果をフォームに適用
    function applyAnalysisResult(perspective, result) {
      if (!result) return;
      
      if (perspective === 'survivor') {
        if (result.rank) document.getElementById('survivor-rank').value = result.rank;
        if (result.myCharacter) document.getElementById('my-survivor').value = result.myCharacter;
        if (result.teammates && result.teammates.length >= 3) {
          document.getElementById('teammate-1').value = result.teammates[0] || '';
          document.getElementById('teammate-2').value = result.teammates[1] || '';
          document.getElementById('teammate-3').value = result.teammates[2] || '';
        }
        if (result.opponentHunter) document.getElementById('opponent-hunter').value = result.opponentHunter;
        if (result.map) document.getElementById('survivor-map').value = result.map;
        if (result.escapeCount !== undefined) {
          selectedEscapeCount.survivor = result.escapeCount;
          document.querySelectorAll('#survivor-input .result-button').forEach((btn, index) => {
            btn.classList.toggle('selected', index === result.escapeCount);
          });
        }
        updateSurvivorSelects();
      } else {
        if (result.rank) document.getElementById('hunter-rank').value = result.rank;
        if (result.myCharacter) document.getElementById('my-hunter').value = result.myCharacter;
        if (result.opponentSurvivors && result.opponentSurvivors.length >= 4) {
          document.getElementById('opponent-survivor-1').value = result.opponentSurvivors[0] || '';
          document.getElementById('opponent-survivor-2').value = result.opponentSurvivors[1] || '';
          document.getElementById('opponent-survivor-3').value = result.opponentSurvivors[2] || '';
          document.getElementById('opponent-survivor-4').value = result.opponentSurvivors[3] || '';
        }
        if (result.map) document.getElementById('hunter-map').value = result.map;
        if (result.escapeCount !== undefined) {
          selectedEscapeCount.hunter = result.escapeCount;
          document.querySelectorAll('#hunter-input .result-button').forEach((btn, index) => {
            btn.classList.toggle('selected', index === result.escapeCount);
          });
        }
        updateOpponentSurvivorSelects();
      }
    }
    
    // サバイバー選択肢を更新（重複を除外）
    function updateSurvivorSelects() {
      const mySurvivor = document.getElementById('my-survivor').value;
      const teammate1 = document.getElementById('teammate-1').value;
      const teammate2 = document.getElementById('teammate-2').value;
      const teammate3 = document.getElementById('teammate-3').value;
      
      const selected = [mySurvivor, teammate1, teammate2, teammate3].filter(v => v);
      
      const selectIds = ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3'];
      
      selectIds.forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        SURVIVORS.forEach(survivor => {
          // 自分が選択中か、他で選択されていない場合のみ表示
          if (survivor === currentValue || !selected.includes(survivor)) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 値を復元
        select.value = currentValue;
      });
    }
    
    // ハンター視点の相手サバイバー選択肢を更新（重複を除外）
    function updateOpponentSurvivorSelects() {
      const survivor1 = document.getElementById('opponent-survivor-1').value;
      const survivor2 = document.getElementById('opponent-survivor-2').value;
      const survivor3 = document.getElementById('opponent-survivor-3').value;
      const survivor4 = document.getElementById('opponent-survivor-4').value;
      
      const selected = [survivor1, survivor2, survivor3, survivor4].filter(v => v);
      
      const selectIds = ['opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'];
      
      selectIds.forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        SURVIVORS.forEach(survivor => {
          // 自分が選択中か、他で選択されていない場合のみ表示
          if (survivor === currentValue || !selected.includes(survivor)) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 値を復元
        select.value = currentValue;
      });
    }
    
    // セレクトボックスにオプションを追加
    function populateSelects() {
      const survivorSelects = ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3', 'opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'];
      survivorSelects.forEach(id => {
        const select = document.getElementById(id);
        SURVIVORS.forEach(survivor => {
          const option = document.createElement('option');
          option.value = survivor;
          option.textContent = survivor;
          select.appendChild(option);
        });
      });
      
      const hunterSelects = ['my-hunter', 'opponent-hunter'];
      hunterSelects.forEach(id => {
        const select = document.getElementById(id);
        HUNTERS.forEach(hunter => {
          const option = document.createElement('option');
          option.value = hunter;
          option.textContent = hunter;
          select.appendChild(option);
        });
      });
      
      const mapSelects = ['survivor-map', 'hunter-map'];
      mapSelects.forEach(id => {
        const select = document.getElementById(id);
        MAPS.forEach(map => {
          const option = document.createElement('option');
          option.value = map;
          option.textContent = map;
          select.appendChild(option);
        });
      });
      
      const rankSelects = ['survivor-rank', 'hunter-rank'];
      rankSelects.forEach(id => {
        const select = document.getElementById(id);
        RANKS.forEach(rank => {
          const option = document.createElement('option');
          option.value = rank;
          option.textContent = rank;
          select.appendChild(option);
        });
      });
      
      // サバイバー選択時の重複チェックを追加
      ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => updateSurvivorSelectOptions());
      });
      
      // ハンター視点のサバイバー選択時の重複チェックを追加
      ['opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'].forEach(id => {
        document.getElementById(id).addEventListener('change', () => updateHunterOpponentSelectOptions());
      });
    }
    
    // サバイバー視点：選択済みキャラを他の選択肢から除外
    function updateSurvivorSelectOptions() {
      const mySurvivor = document.getElementById('my-survivor').value;
      const teammate1 = document.getElementById('teammate-1').value;
      const teammate2 = document.getElementById('teammate-2').value;
      const teammate3 = document.getElementById('teammate-3').value;
      
      const selected = [mySurvivor, teammate1, teammate2, teammate3].filter(v => v);
      
      ['my-survivor', 'teammate-1', 'teammate-2', 'teammate-3'].forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        SURVIVORS.forEach(survivor => {
          // 自分以外で選択されているキャラは除外
          if (!selected.includes(survivor) || survivor === currentValue) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 現在の値を復元
        select.value = currentValue;
      });
    }
    
    // ハンター視点：選択済みキャラを他の選択肢から除外
    function updateHunterOpponentSelectOptions() {
      const opponent1 = document.getElementById('opponent-survivor-1').value;
      const opponent2 = document.getElementById('opponent-survivor-2').value;
      const opponent3 = document.getElementById('opponent-survivor-3').value;
      const opponent4 = document.getElementById('opponent-survivor-4').value;
      
      const selected = [opponent1, opponent2, opponent3, opponent4].filter(v => v);
      
      ['opponent-survivor-1', 'opponent-survivor-2', 'opponent-survivor-3', 'opponent-survivor-4'].forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        
        // 選択肢を再構築
        select.innerHTML = '<option value="">選択してください</option>';
        SURVIVORS.forEach(survivor => {
          // 自分以外で選択されているキャラは除外
          if (!selected.includes(survivor) || survivor === currentValue) {
            const option = document.createElement('option');
            option.value = survivor;
            option.textContent = survivor;
            select.appendChild(option);
          }
        });
        
        // 現在の値を復元
        select.value = currentValue;
      });
    }
    
    // 段位フィルターを設定（使用済み段位のみ）
    function populateRankFilters() {
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      const usedRanks = [...new Set(perspectiveMatches.map(m => m.rank).filter(r => r))];
      
      // RANKS配列の順序を保持してソート
      const sortedRanks = RANKS.filter(rank => usedRanks.includes(rank));
      
      const filterIds = ['character-rank-filter', 'map-rank-filter', 'opponent-rank-filter', 'history-rank-filter'];
      filterIds.forEach(id => {
        const select = document.getElementById(id);
        const currentValue = select.value;
        select.innerHTML = '<option value="all">全段位</option>';
        
        sortedRanks.forEach(rank => {
          const option = document.createElement('option');
          option.value = rank;
          option.textContent = rank;
          select.appendChild(option);
        });
        
        // 前回選択していた値を復元
        if (currentValue && (currentValue === 'all' || sortedRanks.includes(currentValue))) {
          select.value = currentValue;
        }
      });
      
      // マップフィルター（対戦相手別勝率用、自キャラフィルターに連動）
      const myCharFilterValue = document.getElementById('my-char-filter')?.value || 'all';
      updateMapFilter(myCharFilterValue);
      
      // 自キャラフィルター
      updateMyCharFilter();
    }
    
    // マップフィルターを更新（自キャラフィルターに連動）
    function updateMapFilter(selectedChar = 'all') {
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      
      // 自キャラでフィルター
      let filteredMatches = perspectiveMatches;
      if (selectedChar !== 'all') {
        filteredMatches = perspectiveMatches.filter(m => m.myCharacter === selectedChar);
      }
      
      const usedMaps = [...new Set(filteredMatches.map(m => m.map))].sort();
      
      const mapSelect = document.getElementById('opponent-map-filter');
      const currentValue = mapSelect.value;
      mapSelect.innerHTML = '<option value="all">全マップ</option>';
      usedMaps.forEach(map => {
        const option = document.createElement('option');
        option.value = map;
        option.textContent = map;
        mapSelect.appendChild(option);
      });
      
      // 前回選択していた値を復元（存在する場合のみ）
      if (currentValue && (currentValue === 'all' || usedMaps.includes(currentValue))) {
        mapSelect.value = currentValue;
      }
    }
    
    // 自キャラフィルターを更新（使用済みキャラのみ）
    function updateMyCharFilter() {
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      const usedChars = [...new Set(perspectiveMatches.map(m => m.myCharacter))].sort();
      
      // 対戦相手別勝率のフィルター
      const opponentSelect = document.getElementById('my-char-filter');
      opponentSelect.innerHTML = '<option value="all">全キャラ</option>';
      usedChars.forEach(char => {
        const option = document.createElement('option');
        option.value = char;
        option.textContent = char;
        opponentSelect.appendChild(option);
      });
      
      // マップ別勝率のフィルター
      const mapSelect = document.getElementById('map-char-filter');
      mapSelect.innerHTML = '<option value="all">全キャラ</option>';
      usedChars.forEach(char => {
        const option = document.createElement('option');
        option.value = char;
        option.textContent = char;
        mapSelect.appendChild(option);
      });
    }
    
    // 視点を切り替え
    function switchPerspective(perspective) {
      currentPerspective = perspective;
      
      document.querySelectorAll('.perspective-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');
      
      if (perspective === 'survivor') {
        document.getElementById('survivor-input').style.display = 'block';
        document.getElementById('hunter-input').style.display = 'none';
      } else {
        document.getElementById('survivor-input').style.display = 'none';
        document.getElementById('hunter-input').style.display = 'block';
      }
      
      updateAllWithFilters();
    }
    
    // タブを切り替え
    function switchTab(tabName) {
      document.querySelectorAll('.main-tab').forEach(tab => {
        tab.classList.remove('active');
      });
      event.target.classList.add('active');
      
      document.querySelectorAll('.tab-content').forEach(content => {
        content.classList.remove('active');
      });
      document.getElementById(tabName + '-tab').classList.add('active');
      
      updateAllStats();
    }
    
    // 脱出人数を選択
    function selectEscapeCount(perspective, count) {
      selectedEscapeCount[perspective] = count;
      
      const container = perspective === 'survivor' ? document.getElementById('survivor-input') : document.getElementById('hunter-input');
      container.querySelectorAll('.result-button').forEach(btn => {
        btn.classList.remove('selected');
      });
      event.target.classList.add('selected');
    }
    
    // 脱出人数から勝敗を判定
    function getResultFromEscapeCount(escapeCount, perspective) {
      if (perspective === 'survivor') {
        if (escapeCount >= 3) return 'survivor_win';
        if (escapeCount === 2) return 'draw';
        return 'hunter_win';
      } else {
        if (escapeCount <= 1) return 'hunter_win';
        if (escapeCount === 2) return 'draw';
        return 'survivor_win';
      }
    }
    
    // 試合を記録
    function submitMatch(perspective) {
      let match = {
        id: editingMatchId || Date.now(),
        perspective: perspective,
        timestamp: new Date().toISOString()
      };
      
      if (perspective === 'survivor') {
        const rank = document.getElementById('survivor-rank').value;
        const mySurvivor = document.getElementById('my-survivor').value;
        const teammate1 = document.getElementById('teammate-1').value;
        const teammate2 = document.getElementById('teammate-2').value;
        const teammate3 = document.getElementById('teammate-3').value;
        const opponentHunter = document.getElementById('opponent-hunter').value;
        const map = document.getElementById('survivor-map').value;
        const escapeCount = selectedEscapeCount.survivor;
        
        if (!rank || !mySurvivor || !teammate1 || !teammate2 || !teammate3 || !opponentHunter || !map || escapeCount === null) {
          alert('全ての項目を入力してください');
          return;
        }
        
        match.rank = rank;
        match.myCharacter = mySurvivor;
        match.teammates = [teammate1, teammate2, teammate3];
        match.opponentHunter = opponentHunter;
        match.map = map;
        match.escapeCount = escapeCount;
        match.result = getResultFromEscapeCount(escapeCount, perspective);
      } else {
        const rank = document.getElementById('hunter-rank').value;
        const myHunter = document.getElementById('my-hunter').value;
        const opponentSurvivor1 = document.getElementById('opponent-survivor-1').value;
        const opponentSurvivor2 = document.getElementById('opponent-survivor-2').value;
        const opponentSurvivor3 = document.getElementById('opponent-survivor-3').value;
        const opponentSurvivor4 = document.getElementById('opponent-survivor-4').value;
        const map = document.getElementById('hunter-map').value;
        const escapeCount = selectedEscapeCount.hunter;
        
        if (!rank || !myHunter || !opponentSurvivor1 || !opponentSurvivor2 || !opponentSurvivor3 || !opponentSurvivor4 || !map || escapeCount === null) {
          alert('全ての項目を入力してください');
          return;
        }
        
        match.rank = rank;
        match.myCharacter = myHunter;
        match.opponentSurvivors = [opponentSurvivor1, opponentSurvivor2, opponentSurvivor3, opponentSurvivor4];
        match.map = map;
        match.escapeCount = escapeCount;
        match.result = getResultFromEscapeCount(escapeCount, perspective);
      }
      
      if (editingMatchId) {
        matches = matches.filter(m => m.id !== editingMatchId);
        editingMatchId = null;
      }
      
      matches.push(match);
      saveData();
      
      // 前回の入力値を保存（段位と自キャラのみ）
      saveLastInput(perspective, match.rank, match.myCharacter);
      
      resetForm(perspective);
      alert('試合を記録しました！');
      updateAllWithFilters();
    }
    
    // フォームをリセット（段位と自キャラは保持）
    function resetForm(perspective) {
      if (perspective === 'survivor') {
        // 段位と自キャラは保持
        document.getElementById('teammate-1').value = '';
        document.getElementById('teammate-2').value = '';
        document.getElementById('teammate-3').value = '';
        document.getElementById('opponent-hunter').value = '';
        document.getElementById('survivor-map').value = '';
        selectedEscapeCount.survivor = null;
        document.querySelectorAll('#survivor-input .result-button').forEach(btn => {
          btn.classList.remove('selected');
        });
        updateSurvivorSelectOptions(); // 選択肢を更新
      } else {
        // 段位と自キャラは保持
        document.getElementById('opponent-survivor-1').value = '';
        document.getElementById('opponent-survivor-2').value = '';
        document.getElementById('opponent-survivor-3').value = '';
        document.getElementById('opponent-survivor-4').value = '';
        document.getElementById('hunter-map').value = '';
        selectedEscapeCount.hunter = null;
        document.querySelectorAll('#hunter-input .result-button').forEach(btn => {
          btn.classList.remove('selected');
        });
        updateHunterOpponentSelectOptions(); // 選択肢を更新
      }
    }
    
    // データを保存
    function saveData() {
      localStorage.setItem('identity5_matches', JSON.stringify(matches));
    }
    
    // データを読み込み
    function loadData() {
      const saved = localStorage.getItem('identity5_matches');
      if (saved) {
        matches = JSON.parse(saved);
      }
      
      // 前回の入力値を復元
      const lastInputSurvivor = localStorage.getItem('identity5_last_input_survivor');
      if (lastInputSurvivor) {
        const data = JSON.parse(lastInputSurvivor);
        if (data.rank) document.getElementById('survivor-rank').value = data.rank;
        if (data.myCharacter) document.getElementById('my-survivor').value = data.myCharacter;
      }
      
      const lastInputHunter = localStorage.getItem('identity5_last_input_hunter');
      if (lastInputHunter) {
        const data = JSON.parse(lastInputHunter);
        if (data.rank) document.getElementById('hunter-rank').value = data.rank;
        if (data.myCharacter) document.getElementById('my-hunter').value = data.myCharacter;
      }
    }
    
    // 入力値を保存
    function saveLastInput(perspective, rank, myCharacter) {
      const key = `identity5_last_input_${perspective}`;
      localStorage.setItem(key, JSON.stringify({ rank, myCharacter }));
    }
    
    // フィルタリングされたデータを取得
    function getFilteredMatches(rankFilter) {
      let filtered = matches.filter(m => m.perspective === currentPerspective);
      if (rankFilter && rankFilter !== 'all') {
        filtered = filtered.filter(m => m.rank === rankFilter);
      }
      return filtered;
    }
    
    // 自キャラフィルター変更時の処理
    function onMyCharFilterChange() {
      const selectedChar = document.getElementById('my-char-filter').value;
      updateMapFilter(selectedChar);
      updateAllStats();
    }
    
    // 全ての統計を更新
    function updateAllStats() {
      updateOverallStats();
      updateCharacterStats();
      updateMapStats();
      updateOpponentStats();
      updateMatchHistory();
    }
    
    // フィルターを含む全てを更新
    function updateAllWithFilters() {
      populateRankFilters();
      updateAllStats();
    }
    
    // 勝率を計算
    function calculateWinrate(matches, perspective) {
      const totalWithDraws = matches.length; // 引き分けを含む総試合数
      const filtered = matches.filter(m => m.result !== 'draw');
      if (filtered.length === 0) return { wins: 0, losses: 0, draws: totalWithDraws, winrate: '0.0', total: 0, totalWithDraws: totalWithDraws };
      
      const wins = filtered.filter(m => {
        if (perspective === 'survivor') {
          return m.result === 'survivor_win';
        } else {
          return m.result === 'hunter_win';
        }
      }).length;
      
      const losses = filtered.length - wins;
      const draws = matches.filter(m => m.result === 'draw').length;
      const winrate = (wins / filtered.length * 100).toFixed(1);
      
      return { wins, losses, draws, winrate, total: filtered.length, totalWithDraws: totalWithDraws };
    }
    
    // 連勝数を計算
    function calculateWinStreak(matches, perspective) {
      if (matches.length === 0) return 0;
      
      // 最新の試合から遡る
      const sorted = [...matches].sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
      let streak = 0;
      
      for (const match of sorted) {
        if (match.result === 'draw') continue; // 引き分けは無視
        
        const isWin = (perspective === 'survivor' && match.result === 'survivor_win') || 
                      (perspective === 'hunter' && match.result === 'hunter_win');
        
        if (isWin) {
          streak++;
        } else {
          break;
        }
      }
      
      return streak;
    }
    
    // 平均脱出/脱落人数を計算
    function calculateAverageEscapeCount(matches, perspective) {
      if (matches.length === 0) return 0;
      
      const total = matches.reduce((sum, m) => sum + (m.escapeCount || 0), 0);
      return (total / matches.length).toFixed(1);
    }
    
    // 総合勝率を更新（試合入力タブ内）
    function updateOverallStats() {
      const container = document.getElementById('overall-stats-inline');
      const perspectiveMatches = matches.filter(m => m.perspective === currentPerspective);
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '';
        return;
      }
      
      const stats = calculateWinrate(perspectiveMatches, currentPerspective);
      const streak = calculateWinStreak(perspectiveMatches, currentPerspective);
      
      let html = `<div class="stats-card" style="margin-bottom: 20px;">
        <div class="overall-stats-display">
          <div class="winrate-big">${stats.winrate}%</div>
          <div class="record-text">${stats.wins}勝 ${stats.losses}敗 ${stats.draws}分け (${stats.totalWithDraws}試合)</div>`;
      
      if (streak >= 2) {
        html += `<div class="streak-badge"><span class="streak-icon">🔥</span>${streak}連勝中！</div>`;
      }
      
      html += `</div></div>`;
      container.innerHTML = html;
    }
    
    // 自キャラ別勝率を更新
    function updateCharacterStats() {
      const container = document.getElementById('character-stats');
      const rankFilter = document.getElementById('character-rank-filter').value;
      const perspectiveMatches = getFilteredMatches(rankFilter);
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      const characterStats = {};
      
      perspectiveMatches.forEach(match => {
        const char = match.myCharacter;
        if (!characterStats[char]) {
          characterStats[char] = [];
        }
        characterStats[char].push(match);
      });
      
      const sortedChars = Object.keys(characterStats).sort((a, b) => {
        const statsA = calculateWinrate(characterStats[a], currentPerspective);
        const statsB = calculateWinrate(characterStats[b], currentPerspective);
        
        // 勝率で比較
        const winrateA = parseFloat(statsA.winrate);
        const winrateB = parseFloat(statsB.winrate);
        const winrateDiff = winrateB - winrateA;
        if (winrateDiff !== 0) return winrateDiff;
        
        // 勝率が同じなら平均脱出/脱落人数で比較
        const avgEscapeA = parseFloat(calculateAverageEscapeCount(characterStats[a], currentPerspective));
        const avgEscapeB = parseFloat(calculateAverageEscapeCount(characterStats[b], currentPerspective));
        
        if (currentPerspective === 'survivor') {
          // サバイバー: 平均脱出人数が多い順
          const avgDiff = avgEscapeB - avgEscapeA;
          if (Math.abs(avgDiff) > 0.01) return avgDiff;
        } else {
          // ハンター: 平均脱落人数が多い順（脱落 = 4 - 脱出）
          const avgFallA = 4 - avgEscapeA;
          const avgFallB = 4 - avgEscapeB;
          const avgDiff = avgFallB - avgFallA;
          if (Math.abs(avgDiff) > 0.01) return avgDiff;
        }
        
        // それでも同じなら試合数で比較（引き分け含む）
        return statsB.totalWithDraws - statsA.totalWithDraws;
      });
      
      let html = `<div class="stats-card">
        <div class="stats-title">キャラクター別勝率（${currentPerspective === 'survivor' ? 'サバイバー' : 'ハンター'}）</div>
        <div class="bar-chart-horizontal">`;
      
      sortedChars.forEach(char => {
        const stats = calculateWinrate(characterStats[char], currentPerspective);
        const avgEscape = calculateAverageEscapeCount(characterStats[char], currentPerspective);
        const winrateNum = parseFloat(stats.winrate) || 0;
        const barWidth = winrateNum;
        
        const avgText = currentPerspective === 'survivor' 
          ? `平均脱出${avgEscape}人` 
          : `平均脱落${(4 - parseFloat(avgEscape)).toFixed(1)}人`;
        
        const isZero = winrateNum === 0;
        
        html += `
          <div class="bar-row">
            <div class="bar-label-wrapper">
              <div class="bar-label">${char}</div>
              <div class="bar-sublabel">${avgText}<br>${stats.totalWithDraws}試合</div>
            </div>
            <div class="bar-wrapper">
              ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
              <div class="bar-visual" style="width: ${barWidth}%;">
                <div class="bar-value">${stats.winrate}%</div>
              </div>`}
            </div>
          </div>
        `;
      });
      
      html += '</div></div>';
      container.innerHTML = html;
    }
    
    // マップ別勝率を更新
    function updateMapStats() {
      const container = document.getElementById('map-stats');
      const rankFilter = document.getElementById('map-rank-filter').value;
      const charFilter = document.getElementById('map-char-filter').value;
      let perspectiveMatches = getFilteredMatches(rankFilter);
      
      // 自キャラでフィルター
      if (charFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.myCharacter === charFilter);
      }
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      const mapStats = {};
      
      perspectiveMatches.forEach(match => {
        const map = match.map;
        if (!mapStats[map]) {
          mapStats[map] = [];
        }
        mapStats[map].push(match);
      });
      
      const sortedMaps = Object.keys(mapStats).sort((a, b) => {
        const statsA = calculateWinrate(mapStats[a], currentPerspective);
        const statsB = calculateWinrate(mapStats[b], currentPerspective);
        
        // 勝率で比較
        const winrateDiff = parseFloat(statsB.winrate) - parseFloat(statsA.winrate);
        if (winrateDiff !== 0) return winrateDiff;
        
        // 勝率が同じなら試合数で比較（引き分け含む）
        return statsB.totalWithDraws - statsA.totalWithDraws;
      });
      
      let html = `<div class="stats-card">
        <div class="stats-title">マップ別勝率</div>
        <div class="bar-chart-horizontal">`;
      
      sortedMaps.forEach(map => {
        const stats = calculateWinrate(mapStats[map], currentPerspective);
        const winrateNum = parseFloat(stats.winrate) || 0;
        const barWidth = winrateNum;
        const isZero = winrateNum === 0;
        
        html += `
          <div class="bar-row">
            <div class="bar-label-wrapper">
              <div class="bar-label">${map}</div>
              <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分</div>
            </div>
            <div class="bar-wrapper">
              ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
              <div class="bar-visual" style="width: ${barWidth}%;">
                <div class="bar-value">${stats.winrate}%</div>
              </div>`}
            </div>
          </div>
        `;
      });
      
      html += '</div></div>';
      container.innerHTML = html;
    }
    
    // 対戦相手別勝率を更新
    function updateOpponentStats() {
      const container = document.getElementById('opponent-stats');
      const rankFilter = document.getElementById('opponent-rank-filter').value;
      const myCharFilter = document.getElementById('my-char-filter').value;
      const mapFilter = document.getElementById('opponent-map-filter').value;
      let perspectiveMatches = getFilteredMatches(rankFilter);
      
      // 自キャラでフィルター
      if (myCharFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.myCharacter === myCharFilter);
      }
      
      // マップでフィルター
      if (mapFilter !== 'all') {
        perspectiveMatches = perspectiveMatches.filter(m => m.map === mapFilter);
      }
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      if (currentPerspective === 'survivor') {
        const hunterStats = {};
        const teammateStats = {};
        
        perspectiveMatches.forEach(match => {
          const hunter = match.opponentHunter;
          if (!hunterStats[hunter]) {
            hunterStats[hunter] = [];
          }
          hunterStats[hunter].push(match);
          
          match.teammates.forEach(teammate => {
            if (!teammateStats[teammate]) {
              teammateStats[teammate] = [];
            }
            teammateStats[teammate].push(match);
          });
        });
        
        let html = `<div class="stats-card">
          <div class="stats-title">対戦相手ハンター別勝率</div>
          <div class="bar-chart-horizontal">`;
        
        Object.keys(hunterStats).sort((a, b) => {
          const statsA = calculateWinrate(hunterStats[a], currentPerspective);
          const statsB = calculateWinrate(hunterStats[b], currentPerspective);
          
          // 勝率で比較
          const winrateDiff = parseFloat(statsB.winrate) - parseFloat(statsA.winrate);
          if (winrateDiff !== 0) return winrateDiff;
          
          // 勝率が同じなら試合数で比較
          return statsB.totalWithDraws - statsA.totalWithDraws;
        }).forEach(hunter => {
          const stats = calculateWinrate(hunterStats[hunter], currentPerspective);
          const winrateNum = parseFloat(stats.winrate) || 0;
          const barWidth = winrateNum;
          const isZero = winrateNum === 0;
          
          html += `
            <div class="bar-row">
              <div class="bar-label-wrapper">
                <div class="bar-label">${hunter}</div>
                <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分</div>
              </div>
              <div class="bar-wrapper">
                ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
                <div class="bar-visual" style="width: ${barWidth}%;">
                  <div class="bar-value">${stats.winrate}%</div>
                </div>`}
              </div>
            </div>
          `;
        });
        
        html += `</div></div>
          <div class="stats-card">
            <div class="stats-title">味方編成別勝率</div>
            <div class="bar-chart-horizontal">`;
        
        Object.keys(teammateStats).sort((a, b) => {
          const statsA = calculateWinrate(teammateStats[a], currentPerspective);
          const statsB = calculateWinrate(teammateStats[b], currentPerspective);
          
          // 勝率で比較
          const winrateDiff = parseFloat(statsB.winrate) - parseFloat(statsA.winrate);
          if (winrateDiff !== 0) return winrateDiff;
          
          // 勝率が同じなら試合数で比較
          return statsB.totalWithDraws - statsA.totalWithDraws;
        }).slice(0, 15).forEach(teammate => {
          const stats = calculateWinrate(teammateStats[teammate], currentPerspective);
          const winrateNum = parseFloat(stats.winrate) || 0;
          const barWidth = winrateNum;
          const isZero = winrateNum === 0;
          
          html += `
            <div class="bar-row">
              <div class="bar-label-wrapper">
                <div class="bar-label">${teammate}</div>
                <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分</div>
              </div>
              <div class="bar-wrapper">
                ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
                <div class="bar-visual" style="width: ${barWidth}%;">
                  <div class="bar-value">${stats.winrate}%</div>
                </div>`}
              </div>
            </div>
          `;
        });
        
        html += '</div></div>';
        container.innerHTML = html;
        
      } else {
        const survivorStats = {};
        
        perspectiveMatches.forEach(match => {
          match.opponentSurvivors.forEach(survivor => {
            if (!survivorStats[survivor]) {
              survivorStats[survivor] = [];
            }
            survivorStats[survivor].push(match);
          });
        });
        
        let html = `<div class="stats-card">
          <div class="stats-title">対戦相手サバイバー別勝率</div>
          <div class="bar-chart-horizontal">`;
        
        Object.keys(survivorStats).sort((a, b) => {
          const statsA = calculateWinrate(survivorStats[a], currentPerspective);
          const statsB = calculateWinrate(survivorStats[b], currentPerspective);
          
          // 勝率で比較
          const winrateDiff = parseFloat(statsB.winrate) - parseFloat(statsA.winrate);
          if (winrateDiff !== 0) return winrateDiff;
          
          // 勝率が同じなら試合数で比較
          return statsB.totalWithDraws - statsA.totalWithDraws;
        }).slice(0, 20).forEach(survivor => {
          const stats = calculateWinrate(survivorStats[survivor], currentPerspective);
          const winrateNum = parseFloat(stats.winrate) || 0;
          const barWidth = winrateNum;
          const isZero = winrateNum === 0;
          
          html += `
            <div class="bar-row">
              <div class="bar-label-wrapper">
                <div class="bar-label">${survivor}</div>
                <div class="bar-sublabel">${stats.wins}勝${stats.losses}敗${stats.draws}分</div>
              </div>
              <div class="bar-wrapper">
                ${isZero ? `<div class="bar-value-zero">${stats.winrate}%</div>` : `
                <div class="bar-visual" style="width: ${barWidth}%;">
                  <div class="bar-value">${stats.winrate}%</div>
                </div>`}
              </div>
            </div>
          `;
        });
        
        html += '</div></div>';
        container.innerHTML = html;
      }
    }
    
    // 試合履歴を更新
    function updateMatchHistory() {
      const container = document.getElementById('match-history');
      const rankFilter = document.getElementById('history-rank-filter').value;
      const perspectiveMatches = getFilteredMatches(rankFilter).reverse();
      
      if (perspectiveMatches.length === 0) {
        container.innerHTML = '<div class="empty-state"><p>まだ試合データがありません</p></div>';
        return;
      }
      
      let html = '<div class="match-history">';
      
      perspectiveMatches.forEach(match => {
        const resultText = match.result === 'survivor_win' ? 'サバイバー勝利' : match.result === 'hunter_win' ? 'ハンター勝利' : '引き分け';
        const isWin = (currentPerspective === 'survivor' && match.result === 'survivor_win') || 
                      (currentPerspective === 'hunter' && match.result === 'hunter_win');
        const displayResultClass = isWin ? 'win' : match.result === 'draw' ? 'draw' : 'lose';
        const escapeInfo = match.escapeCount !== undefined ? ` (脱出${match.escapeCount}人)` : '';
        const rankInfo = match.rank ? `[${match.rank}] ` : '';
        
        let details = '';
        if (match.perspective === 'survivor') {
          details = `${rankInfo}${match.myCharacter} + ${match.teammates.join(', ')} vs ${match.opponentHunter} @ ${match.map}${escapeInfo}`;
        } else {
          details = `${rankInfo}${match.myCharacter} vs ${match.opponentSurvivors.join(', ')} @ ${match.map}${escapeInfo}`;
        }
        
        html += `
          <div class="match-item">
            <div class="match-info">
              <span class="match-result ${displayResultClass}">${resultText}</span>
              <span>${details}</span>
            </div>
            <div class="match-actions">
              <button class="edit-button" onclick="editMatch(${match.id})">編集</button>
              <button class="delete-button" onclick="deleteMatch(${match.id})">削除</button>
            </div>
          </div>
        `;
      });
      
      html += '</div>';
      container.innerHTML = html;
    }
    
    // 試合を編集
    function editMatch(id) {
      const match = matches.find(m => m.id === id);
      if (!match) return;
      
      editingMatchId = id;
      
      if (match.perspective === 'survivor') {
        currentPerspective = 'survivor';
        document.getElementById('survivor-rank').value = match.rank || '';
        document.getElementById('my-survivor').value = match.myCharacter;
        document.getElementById('teammate-1').value = match.teammates[0];
        document.getElementById('teammate-2').value = match.teammates[1];
        document.getElementById('teammate-3').value = match.teammates[2];
        document.getElementById('opponent-hunter').value = match.opponentHunter;
        document.getElementById('survivor-map').value = match.map;
        selectedEscapeCount.survivor = match.escapeCount !== undefined ? match.escapeCount : null;
        
        document.querySelectorAll('.perspective-tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.perspective-tab')[0].classList.add('active');
        document.getElementById('survivor-input').style.display = 'block';
        document.getElementById('hunter-input').style.display = 'none';
        
        updateSurvivorSelects(); // 選択肢を更新
        
        document.querySelectorAll('#survivor-input .result-button').forEach((btn, index) => {
          btn.classList.remove('selected');
          if (match.escapeCount !== undefined && index === match.escapeCount) {
            btn.classList.add('selected');
          }
        });
        
        // 選択肢を更新
        updateSurvivorSelectOptions();
      } else {
        currentPerspective = 'hunter';
        document.getElementById('hunter-rank').value = match.rank || '';
        document.getElementById('my-hunter').value = match.myCharacter;
        document.getElementById('opponent-survivor-1').value = match.opponentSurvivors[0];
        document.getElementById('opponent-survivor-2').value = match.opponentSurvivors[1];
        document.getElementById('opponent-survivor-3').value = match.opponentSurvivors[2];
        document.getElementById('opponent-survivor-4').value = match.opponentSurvivors[3];
        document.getElementById('hunter-map').value = match.map;
        selectedEscapeCount.hunter = match.escapeCount !== undefined ? match.escapeCount : null;
        
        document.querySelectorAll('.perspective-tab').forEach(tab => tab.classList.remove('active'));
        document.querySelectorAll('.perspective-tab')[1].classList.add('active');
        document.getElementById('survivor-input').style.display = 'none';
        document.getElementById('hunter-input').style.display = 'block';
        
        updateHunterOpponentSelectOptions(); // 選択肢を更新
        
        document.querySelectorAll('#hunter-input .result-button').forEach((btn, index) => {
          btn.classList.remove('selected');
          if (match.escapeCount !== undefined && index === match.escapeCount) {
            btn.classList.add('selected');
          }
        });
      }
      
      document.querySelectorAll('.main-tab').forEach(tab => tab.classList.remove('active'));
      document.querySelectorAll('.main-tab')[0].classList.add('active');
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      document.getElementById('input-tab').classList.add('active');
      
      window.scrollTo(0, 0);
    }
    
    // 試合を削除
    function deleteMatch(id) {
      if (!confirm('この試合データを削除しますか？')) return;
      
      matches = matches.filter(m => m.id !== id);
      saveData();
      updateAllWithFilters();
      alert('試合データを削除しました');
    }
    
    // 全データをリセット
    function resetAllData() {
      if (!confirm('本当に全てのデータをリセットしますか？この操作は取り消せません。')) return;
      
      matches = [];
      saveData();
      updateAllWithFilters();
      alert('全データをリセットしました');
    }
    
    window.addEventListener('DOMContentLoaded', init);
  </script>
</body>
</html>
